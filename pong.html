<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Pong Game</title>
<style>
body {
    background: #222;
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
}

#game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

#pong-canvas {
    background: #000;
    border: 3px solid #fff;
    display: block;
    margin-bottom: 10px;
}

#score {
    font-size: 2rem;
    font-weight: bold;
    letter-spacing: 1px;
}
</style>
    </head>
<body>
    <div id="game-container">
        <canvas id="pong-canvas" width="800" height="500"></canvas>
        <div id="score">
            <span id="player-score">0</span> : <span id="ai-score">0</span>
        </div>
    </div>
    <script >const canvas = document.getElementById('pong-canvas');
const ctx = canvas.getContext('2d');

// Game settings
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// Paddle settings
const PADDLE_WIDTH = 10;
const PADDLE_HEIGHT = 100;
const PADDLE_MARGIN = 20;
const PADDLE_SPEED = 6;

// Ball settings
const BALL_SIZE = 12;
const BALL_SPEED = 5;

// Scores
let playerScore = 0;
let aiScore = 0;

// Paddles
let playerPaddle = {
    x: PADDLE_MARGIN,
    y: HEIGHT / 2 - PADDLE_HEIGHT / 2,
    width: PADDLE_WIDTH,
    height: PADDLE_HEIGHT
};

let aiPaddle = {
    x: WIDTH - PADDLE_MARGIN - PADDLE_WIDTH,
    y: HEIGHT / 2 - PADDLE_HEIGHT / 2,
    width: PADDLE_WIDTH,
    height: PADDLE_HEIGHT
};

// Ball
let ball = {
    x: WIDTH / 2 - BALL_SIZE / 2,
    y: HEIGHT / 2 - BALL_SIZE / 2,
    size: BALL_SIZE,
    dx: BALL_SPEED * (Math.random() > 0.5 ? 1 : -1),
    dy: BALL_SPEED * (Math.random() * 2 - 1)
};

// Mouse control for player paddle
canvas.addEventListener('mousemove', function(e) {
    const rect = canvas.getBoundingClientRect();
    let mouseY = e.clientY - rect.top;
    playerPaddle.y = mouseY - playerPaddle.height / 2;
    // Clamp to canvas
    if (playerPaddle.y < 0) playerPaddle.y = 0;
    if (playerPaddle.y + playerPaddle.height > HEIGHT) playerPaddle.y = HEIGHT - playerPaddle.height;
});

// Draw functions
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
}

function drawBall(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, size, size);
}

function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw paddles
    drawRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height, '#fff');
    drawRect(aiPaddle.x, aiPaddle.y, aiPaddle.width, aiPaddle.height, '#fff');

    // Draw ball
    drawBall(ball.x, ball.y, ball.size, '#ff0');

    // Draw center line
    for (let i = 0; i < HEIGHT; i += 30) {
        drawRect(WIDTH / 2 - 2, i, 4, 20, '#555');
    }
}

// Update ball position and handle collision
function updateBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Top/bottom wall collision
    if (ball.y < 0) {
        ball.y = 0;
        ball.dy *= -1;
    }
    if (ball.y + ball.size > HEIGHT) {
        ball.y = HEIGHT - ball.size;
        ball.dy *= -1;
    }

    // Left paddle collision
    if (
        ball.x < playerPaddle.x + playerPaddle.width &&
        ball.y + ball.size > playerPaddle.y &&
        ball.y < playerPaddle.y + playerPaddle.height
    ) {
        ball.x = playerPaddle.x + playerPaddle.width;
        ball.dx *= -1;
        // Add spin based on paddle movement
        let deltaY = ball.y + ball.size / 2 - (playerPaddle.y + playerPaddle.height / 2);
        ball.dy = deltaY * 0.25;
    }

    // Right (AI) paddle collision
    if (
        ball.x + ball.size > aiPaddle.x &&
        ball.y + ball.size > aiPaddle.y &&
        ball.y < aiPaddle.y + aiPaddle.height
    ) {
        ball.x = aiPaddle.x - ball.size;
        ball.dx *= -1;
        let deltaY = ball.y + ball.size / 2 - (aiPaddle.y + aiPaddle.height / 2);
        ball.dy = deltaY * 0.25;
    }

    // Left wall missed (AI scores)
    if (ball.x < 0) {
        aiScore++;
        resetBall();
        updateScore();
    }

    // Right wall missed (Player scores)
    if (ball.x + ball.size > WIDTH) {
        playerScore++;
        resetBall();
        updateScore();
    }
}

// Simple AI: paddle follows ball with a bit of lag
function updateAIPaddle() {
    let targetY = ball.y + ball.size / 2 - aiPaddle.height / 2;
    if (aiPaddle.y < targetY) {
        aiPaddle.y += PADDLE_SPEED;
    } else if (aiPaddle.y > targetY) {
        aiPaddle.y -= PADDLE_SPEED;
    }
    // Clamp to canvas
    if (aiPaddle.y < 0) aiPaddle.y = 0;
    if (aiPaddle.y + aiPaddle.height > HEIGHT) aiPaddle.y = HEIGHT - aiPaddle.height;
}

function resetBall() {
    ball.x = WIDTH / 2 - BALL_SIZE / 2;
    ball.y = HEIGHT / 2 - BALL_SIZE / 2;
    ball.dx = BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
    ball.dy = BALL_SPEED * (Math.random() * 2 - 1);
}

function updateScore() {
    document.getElementById('player-score').textContent = playerScore;
    document.getElementById('ai-score').textContent = aiScore;
}

function gameLoop() {
    updateBall();
    updateAIPaddle();
    draw();
    requestAnimationFrame(gameLoop);
}

// Initial score update and start game
updateScore();
gameLoop();</script>
</body>
</html>



